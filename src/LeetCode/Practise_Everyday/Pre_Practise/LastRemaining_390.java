package LeetCode.Practise_Everyday.Pre_Practise;

/**
 * @Auther: Lil_boat
 * @Date: 10:31 2022/1/4
 * @Description: 列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法：
 * <p>
 * 从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。
 * 重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。
 * 不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
 * 给你整数 n ，返回 arr 最后剩下的数字。
 */
public class LastRemaining_390 {
    /*
    方法一：等差数列模拟
        思路与算法
            依照题意，我们每次都将整数列表进行间隔删除，因此每次删除后剩余的整数列表都是等差数列。
            假设第 k 次删除后的等差数列的首元素为 a_1^k，末尾元素为 a_n^k，公差为 step_k，元素数目为 cnt_k，
            则第 k+1 次删除后的等差数列满足：
                    step_k+1 = step_k * 2;
                    cnt_k+1 = cnt_k / 2 取下限
            初始时 k=0，表示尚未删除任何元素。
            如果 k 是偶数，则从左向右删除。
                如果元素数目 cnt_k为奇数，则两端的元素都会被删除。
                    a_1^k+1 = a_1^k + step_k
                    a_n^k+1 = a_n^k - step_k
                如果元素数目 cnt_k为偶数，则首端元素会被删除，末端元素不会被删除。
                    a_1^k+1 = a_1^k + step_k
                    a_n^k+1 = a_n^k
            如果 k 是奇数，则从右向左删除。
                如果元素数目 cnt_k为奇数，则两端的元素都会被删除。
                    a_1^k+1 = a_1^k + step_k
                    a_n^k+1 = a_n^k - step_k
                如果元素数目 cnt_k为偶数，则首端元素不会被删除，末端元素会被删除。
                    a_1^k+1 = a_1^k
                    a_n^k+1 = a_n^k - step_k
            当等差数列只剩一个元素，即 cnt_k=1 时，返回首元素 a_1^k即可。
            注意到末尾元素 a_n^k,可以使用首元素 a_1^k、公差 step_k和元素数目 cnt_k表示：
                    a_n^k = a_1^k + step_k * (cnt_k - 1)
            因此可以省略末尾元素 a_n^k。
     */
    public static int lastRemaining(int n) {
        int step = 1;
        int first = 1;
        int remain = n;
        boolean isLeft = true;
        while (remain > 1) {
            // 如果是从左边开始删除元素
            // 或者删除完元素之后剩余的元素是奇数个
            // first都要加上step
            if (isLeft || (remain & 1) == 1) first += step;
            // 表示从右开始删除
            isLeft = !isLeft;
            // 步长乘2
            step *= 2;
            // 剩余的个数
            remain /= 2;
        }
        return first;
    }

    /*
    约瑟夫环
        与求解约瑟夫环类似，本题也可以通常找规律，分析出公式之后进行递推求解。
        对于本题，定义 f[i] 为在 连续序列 [1, i] 中进行「起始从左到右」的轮流换向间隔删除，最终左边剩余的编号；
        定义 f'[i]为在 连续序列 [1, i] 中进行「起始从右到左」的轮流换向间隔删除，最终右边剩余的编号。
        由于「从左往右」和「从右往左」分别为「从左端点发起，间隔删除」和「从右端点发起，间隔删除」，
        因此整个删除过程在连续序列中 [1, i] 中具有对称性，两者最终剩余的编号在连续序列中也具有对称性。
        即可得出第一个公式：
                                f[i] + f'[i] = i + 1
        考虑题目规定的「左右轮流进行发起删除」的操作如何进行。
        由于我们对 f[i] 和 f'[i]的定义都是「连续序列」，因此如果我们希望使用 f[i] 和 f'[i] 得出最终答案，
        我们需要在每次消除后对序列进行「重新编号」，确保能够使用 f[i] 和 f'[i]作为合法状态值，在计算出「重新编号」后的，需要将答案（编号）映射回去重新编号前的值。
        起始时，我们对连续序列 [1, 2, 3, ... , i] 执行了一次「从左往右」的消除之后，
        得到的序列为 [2, 4, 6, ..., x]（其中 x 根据 i 的奇偶性不同，可能为 i 或 i - 1）。新序列的长度为 ⌊i/2⌋。
        考虑对得到的序列进行重新编号，使其继续保有「连续序列」的定义，即变为 [1, 2, 3, ... , ⌊i/2⌋]，然后执行「从右往左」的间隔删除，
        最终得到 f'[⌊i/2⌋]，之后考虑将答案编号映射回「重新编号」前的值。
        此时可得到第二个公式：
                                f[i] = f'[⌊i/2⌋] * 2
        通过上述两个公式，我们可以将 f'[i]进行消除，得到最终的 f[i] 关系式：
                                f[i] = 2 * (⌊i/2⌋ + 1 - f[⌊i/2⌋])
        我们知道需要实现的函数 lastRemaining 其实就是 f[i]，因此该递推过程我们可以使用递归进行实现（注意的出口条件 f[1] = 1）。
     */
    public static int lastRemaining_Josephus(int n) {
        return n == 1 ? 1 : 2 * (n / 2 + 1 - lastRemaining(n / 2));
    }

    public static void main(String[] args) {
        System.out.println(lastRemaining(100000));
        System.out.println(lastRemaining_Josephus(100000));
    }
}
